
from typing import List, Tuple, Dict
from abc import ABC, abstractmethod

from cat.mad_hatter.decorators import CatTool
from cat.utils import BaseModelDict
from cat.log import log



############# MANU classes #################

class LLMAction(BaseModelDict):
    """
    Represents an action (tool call) requested by the LLM.

    This class encapsulates the details of a tool or function call that
    an LLM wants to execute, including input parameters, output results,
    and execution metadata.

    Attributes
    ----------
    id : str | None, optional
        Unique identifier for the action call, used to match requests
        with responses in LLM API interactions, by default None.
    name : str
        The name of the tool or function to call.
    input : Dict
        Dictionary containing the input parameters for the tool call.
    output : str | None, optional
        The result of executing the tool call, by default None.
    return_direct : bool, optional
        Whether the tool output should be returned directly to the user
        without further LLM processing, by default False.

    Notes
    -----
    The id field is crucial for matching tool call requests with responses.
    This is a strict requirement for LLM APIs that support tool calling,
    """
    id: str | None = None
    name: str
    input: Dict | None = None
    output: str | None = None
    return_direct: bool = False


class AgentOutput(BaseModelDict):
    """
    Represents the output from an agent execution including text and actions.

    Attributes
    ----------
    output : str | None, optional
        The textual output generated by the agent, by default None.
    actions : List[LLMAction], optional
        List of actions (tool calls) executed by the agent, by default [].
    """
    output: str | None = None
    actions: List[LLMAction] = []

    @property
    def intermediate_steps(self) -> List[Tuple[Tuple[str, Dict], str]]:
        """Return the list of actions as intermediate steps for compatibility."""
        return [((action.name, action.input), action.output) for action in self.actions]
    

#############################################


class BaseAgent(ABC):
    
    # using name, ChatRequest can require a specific agent and agents can trigger sub hooks
    name = "base"

    def __init__(self, cat):
        # important so all agents have the session and utilities at disposal
        # if you subclass and override the constructor, remember to set it or call super()
        self.cat = cat

    @abstractmethod
    async def execute(*args, **kwargs) -> AgentOutput:
        """Main Agent method, must be implemented to subclass BaseAgent"""
        pass

    async def get_system_prompt(self) -> str:

        # obtain prompt parts from plugins
        # TODOV2: give better naming to these hooks
        prompt_prefix = self.cat.mad_hatter.execute_hook(
            "agent_prompt_prefix",
            self.cat.chat_request.instructions,
            cat=self.cat
        )
        prompt_suffix = self.cat.mad_hatter.execute_hook(
            "agent_prompt_suffix", "", cat=self.cat
        )

        return prompt_prefix + prompt_suffix

    async def get_tools(self) -> List[CatTool]:
        """Get both plugins' tools and MCP tools in CatTool format.
        """

        mcp_tools = [] #await self.cat.mcp.list_tools()
        internal_tools = self.cat.mad_hatter.tools

        tools = mcp_tools + internal_tools
        #log.critical(tools)

        # TODOV2: conversions? see Emanuele's plugin agent_factory
        # TODOV2: run a hook to inspect and select (with dynamic name)

        return tools

    #async def human_in_the_loop() -> 
    # TODOV2: deal with tool confirmations or json_schema fills
    #               that required human in the loop
