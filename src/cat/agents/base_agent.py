from typing import List, Tuple, Dict
from abc import ABC, abstractmethod

from cat.mad_hatter.decorators import CatTool
from cat.utils import BaseModelDict
from cat.log import log



############# MANU classes #################

class LLMAction(BaseModelDict):
    """
    Represents an action (tool call) requested by the LLM.

    This class encapsulates the details of a tool or function call that
    an LLM wants to execute, including input parameters, output results,
    and execution metadata.

    Attributes
    ----------
    id : str | None, optional
        Unique identifier for the action call, used to match requests
        with responses in LLM API interactions, by default None.
    name : str
        The name of the tool or function to call.
    input : Dict
        Dictionary containing the input parameters for the tool call.
    output : str | None, optional
        The result of executing the tool call, by default None.
    return_direct : bool, optional
        Whether the tool output should be returned directly to the user
        without further LLM processing, by default False.

    Notes
    -----
    The id field is crucial for matching tool call requests with responses.
    This is a strict requirement for LLM APIs that support tool calling,
    """
    id: str | None = None
    name: str
    input: Dict
    output: str | None = None
    return_direct: bool = False


class AgentOutput(BaseModelDict):
    """
    Represents the output from an agent execution including text and actions.

    Attributes
    ----------
    output : str | None, optional
        The textual output generated by the agent, by default None.
    actions : List[LLMAction], optional
        List of actions (tool calls) executed by the agent, by default [].
    """
    output: str | None = None
    actions: List[LLMAction] = []

    @property
    def intermediate_steps(self) -> List[Tuple[Tuple[str, Dict], str]]:
        """Return the list of actions as intermediate steps for compatibility."""
        return [((action.name, action.input), action.output) for action in self.actions]
    

#############################################


class BaseAgent(ABC):
    
    # using name, ChatRequest can require a specific agent and agents can trigger sub hooks
    name = "base"

    async def get_system_prompt(self, cat) -> str:

        # obtain prompt parts from plugins
        # TODOV2: give better naming to these hooks
        prompt_prefix = cat.mad_hatter.execute_hook(
            "agent_prompt_prefix",
            cat.chat_request.instructions,
            cat=cat
        )
        prompt_suffix = cat.mad_hatter.execute_hook(
            "agent_prompt_suffix", "", cat=cat
        )

        return prompt_prefix + prompt_suffix

    async def get_tools(self, cat) -> List[CatTool]:

        mcp_tools = [] #await cat.mcp.list_tools()
        internal_tools = cat.mad_hatter.tools

        tools = mcp_tools + internal_tools
        #log.critical(tools)

        # TODOV2: conversions? see Emanuele's plugin agent_factory
        # TODOV2: run a hook to inspect and select (with dynamic name)

        return tools
    

    # async def get_mcp_resources(self, cat):
    #     resources = await cat.mcp.list_resources()
    #     # TODOV2: run a hook to inspect and select
    #     return resources

    # async def get_mcp_prompts(self, cat):
    #     prompts = await cat.mcp.list_prompts()
    #     # TODOV2: run a hook to inspect and select
    #     return prompts

    #async def human_in_the_loop(cat) -> 
    # TODOV2: deal with tool confirmations or json_schema fills
    #               that required human in the loop

    @abstractmethod
    async def execute(*args, **kwargs) -> AgentOutput:
        pass